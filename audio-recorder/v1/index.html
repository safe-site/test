<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Online Audio Recorder - Recording Tool</title>
  <style>
    body {
      background-color: #1f1f1f;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      margin: 0;
    }

    h1 {
      color: #61dafb;
    }

    #recordingButton {
      background-color: #61dafb;
      color: #fff;
      padding: 15px 30px;
      margin: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }

    #recordingButton.recording {
      background-color: #ff5555;
    }

    #audioPlayer {
      width: 100%;
      max-width: 300px;
      margin-top: 20px;
    }

    canvas {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Online Audio Recorder - Recording Tool</h1>
  <button id="recordingButton">Record</button>
  <audio id="audioPlayer" controls></audio>
  <canvas id="waveCanvas" width="500" height="100"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      let mediaRecorder;
      let audioChunks = [];
      let isRecording = false;

      const recordingButton = document.getElementById('recordingButton');
      const audioPlayer = document.getElementById('audioPlayer');
      const waveCanvas = document.getElementById('waveCanvas');
      const canvasContext = waveCanvas.getContext('2d');

      recordingButton.addEventListener('click', () => {
        if (!isRecording) {
          startRecording();
        } else {
          stopRecording();
        }
      });

      function startRecording() {
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then((stream) => {
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                audioChunks.push(event.data);
                drawWaveform();
              }
            };

            mediaRecorder.onstop = () => {
              const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
              const audioUrl = URL.createObjectURL(audioBlob);
              audioPlayer.src = audioUrl;
            };

            mediaRecorder.start();
            isRecording = true;
            updateButtonAppearance();
          })
          .catch((error) => {
            console.error('Error accessing microphone:', error);
          });
      }

      function stopRecording() {
        if (mediaRecorder) {
          mediaRecorder.stop();
          isRecording = false;
          updateButtonAppearance();
        }
      }

      function updateButtonAppearance() {
        recordingButton.classList.toggle('recording', isRecording);
        recordingButton.innerText = isRecording ? 'Stop Recording' : 'Start Recording';
      }

      function drawWaveform() {
        const analyser = new AnalyserNode(audioContext);
        const source = audioContext.createBufferSource();
        audioContext.decodeAudioData(audioChunks[0], (buffer) => {
          source.buffer = buffer;
          source.connect(analyser);
          analyser.connect(audioContext.destination);
          source.start();

          const dataArray = new Uint8Array(analyser.fftSize);
          canvasContext.clearRect(0, 0, waveCanvas.width, waveCanvas.height);

          function draw() {
            analyser.getByteTimeDomainData(dataArray);
            canvasContext.fillStyle = '#61dafb';
            canvasContext.lineWidth = 2;
            canvasContext.strokeStyle = '#61dafb';
            canvasContext.beginPath();

            const sliceWidth = waveCanvas.width / dataArray.length;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
              const v = dataArray[i] / 128.0;
              const y = v * waveCanvas.height / 2;

              if (i === 0) {
                canvasContext.moveTo(x, y);
              } else {
                canvasContext.lineTo(x, y);
              }

              x += sliceWidth;
            }

            canvasContext.lineTo(waveCanvas.width, waveCanvas.height / 2);
            canvasContext.stroke();

            requestAnimationFrame(draw);
          }

          draw();
        });
      }
    });
  </script>
</body>
</html>
